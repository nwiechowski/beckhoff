MEMORY
{
	IRTable (rx) :		org = 0x00010000, len = 0x00010000
	rom (rx) :			org = 0x00020000, len = 0x00090000
	param_rom (r) :		org = 0x000C0000, len = 0x00015000
	param_ram (rw) :	org = 0x40000000, len = 0x00015000
	ram (rw) :			org = 0x40015000, len = 0x00015000 
    stack (rw) :		org = 0x4002A000, len = 0x00010000 
}

PHDRS
{
	text PT_LOAD;
	ram PT_LOAD;
	ram_init PT_LOAD;
	ram_param PT_LOAD;
	tls PT_TLS;
}

SECTIONS
{	
	.IRTable : {
		FILL(0xFFFFFFFF);
		__IR_TABLE = ABSOLUTE(.);
		KEEP(*(.IRTable));
		. = ORIGIN(rom) - 0xa0;
		KEEP(*(.baseconfig));
		. = ORIGIN(rom) - 0x20;
		__OSINFO = ABSOLUTE(.);
		*(.osinfo)
	} >IRTable AT>IRTable :text
	
	/DISCARD/ : {
		/* remove some unused meta information which are generated by srec_cat in the vera_proginfo.c file */
		vera_proginfo.o(.rodata)
	} :NONE
	
	.text : {
		*(.startup)		/* Initialization code from crt0.s */
		*(.text .text.*)		/* Executable instructions */
		*(.got*)		/* Global offset table */
		KEEP(*(.init))	/* This section holds executable instructions that contribute to the process initialization code. When a program starts to run, the system arranges to execute the code in this section before calling the main program entry point (called main for C programs) */
		KEEP(*(.fini))	/* This section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section. */

		*(.rodata .rodata.*)		/* This section holds read-only data that typically contribute to a non-writable segment in the process image. */
		*(.data.rel.ro .data.rel.ro.*)
		
		_SDA2_BASE_ = ABSOLUTE(.) + 0x7ff0;
		*(.sdata2)
		*(.sbss2 .sbss2.*)
		FILL(0xFFFFFFFF);
		. = ALIGN(8);
	} >rom AT>rom :text
	
	.data : {
		__DATA_RAM	= ABSOLUTE(.);
		*(.data .data.*)		/* This section holds initialized data that contribute to the program's memory image. */

		_SDA_BASE_ = ABSOLUTE(.) + 0x7ff0;
		*(.sdata .sdata.*)
		FILL(0xFFFFFFFF);
		. = ALIGN(8);
	} >ram AT>rom :ram_init
	
	/* Thread local initialized data. This gets
	 * space allocated as it is expected to be placed
	 * in ram to be used as a template for TLS data blocks
	 * allocated at runtime. We're slightly abusing that
	 * by placing the data in flash where it will be copied
	 * into the allocate ram addresses by the existing
	 * data initialization code in crt0
	 */
	.tdata : {
		PROVIDE( __tls_base = . + 0x7000);
		*(.tdata .tdata.*)
		PROVIDE( __DATA_END	= ABSOLUTE(.) );
	} >ram AT>rom :tls :ram_init
	
	PROVIDE( __tdata_source = LOADADDR(.tdata) );
	PROVIDE( __tdata_size = SIZEOF(.tdata) );
	PROVIDE( __DATA_ROM = LOADADDR(.data) );
	PROVIDE( __DATA_ROM_END = LOADADDR(.tdata) + SIZEOF(.tdata) );

	.tbss (NOLOAD) : {
		__BSS_START	= ABSOLUTE(.);
		*(.tbss .tbss.*)
		*(.tcommon)
		PROVIDE( __tls_end = . );
	} >ram AT>ram :tls :ram
	PROVIDE( __tbss_size = SIZEOF(.tbss) );
	PROVIDE( __tls_size = __tls_end - __tls_base );

	/*
	 * The linker special cases .tbss segments which are
	 * identified as segments which are not loaded and are
	 * thread_local.
	 *
	 * For these segments, the linker does not advance 'dot'
	 * across them.  We actually need memory allocated for tbss,
	 * so we create a special segment here just to make room
	 */
	.tbss_space (NOLOAD) : {
		. = . + __tbss_size;
	} >ram AT>ram :NONE

	.bss (NOLOAD) : {
		*(.sbss*)
		*(.bss .bss.*)
		*(COMMON);
		__BSS_END = ABSOLUTE(.);
	
		__HEAP_START = ABSOLUTE(.);
	} >ram AT>ram :NONE
	
	
	.param_ram : {
		__PARAM_RAM	= ABSOLUTE(.);
		*(.param_data)
		__PARAM_END = ABSOLUTE(.);
	} >param_ram AT>param_rom :ram_param
	
	PROVIDE( __PARAM_ROM = LOADADDR(.param_ram) );
	PROVIDE( __PARAM_ROM_END = LOADADDR(.param_ram) + SIZEOF(.param_ram) );
	
	
	.stack (NOLOAD) : {
		__SP_END = ABSOLUTE(.);
		. += LENGTH(stack);
		__SP_INIT = (. & ~ 3);
		__USER_STACK_TOP = (. & ~ 3);
	} >stack :NONE
}

__BASEINFO = 0x1000;
__HEAP_END = ORIGIN(ram) + LENGTH(ram);
__SRAM_BASE_ADDR = ORIGIN(param_ram);
__SRAM_SIZE = LENGTH(param_ram) + LENGTH(ram) + LENGTH(stack);

EXTERN(eppc_exception)
EXTERN(_baseConfig)
ENTRY(_start)